import numpy as np
import fitsio
import argparse
from pathlib import Path
import statsmodels.api as sm
import logging


def rlm_fit1d(x, y, t=1.5, order=1):
    '''
    1D robust polynomial fit.
    
    Given x array and y array, calculate the 1D robust 
    polynomial fit of arbitrary order. Huber weight
    function is used. 
    
    See also poly_val1d.py
    
    INPUT:
    1D arrays of x and y values; tunning parameter t; 
    order of the polynomial fit.
    
    OUTPUT:
    Array of parameters of the polynomial [a0, a1, a2 ...] 
    so that y = a0 + a1*x + a2*x**2 + ...
    '''
    

    ncols = order+1
    a = np.zeros((x.size,ncols))
    for i in range(order+1):
        a[:,i] = x**i
    res = sm.RLM(y, a, M=sm.robust.norms.HuberT(t=t)).fit()
    m = res.params
    # this should spit out se and uncertainty as well
    return m


def poly_val1d(x, m):
    '''
    Evaluate the 1D polynomial from x values and polynomial parameters
    
    See also rlm_fit1d.py
    
    INPUT:
    1D array of x values; 
    1D array of polynomial parameters (for example generated by 
    rlm_fit1d.py).
    
    OUTPUT:
    1D array of the evaluated values of the polynomial.
    '''
    
    order = len(m)-1
    z = np.zeros(x.shape)
    for i in range(order+1):
        z += m[i] * x**i
    return z

def extract_images(filelist, input_dir, output_dir):
    pass

def find_best_focus(filelist: list, focuses: list, center_x, center_y, half_sidelen, 
                    filter_name: str, input_dir, output_dir):
    """_summary_

    Parameters
    ----------
    filelist : list
        a list of file names
    focuses : list
        a list of corresponding focus values for each image
    center_x : int or list
        x coordinate of the center of the star. If a single value, then
        use this value for all images. If a list, then use the corresponding
        center_x for each image.
    center_y : int or list
        y coordinate of the center of the star. If a single value, then
        use this value for all images. If a list, then use the corresponding
        center_y for each image.
    half_sidelen : int
        half side length of the square region to extract the star
    filter_name : str
        filter name
    input_dir : str or path-like
        input directory
    output_dir : str or path-like
        output directory
    """    
    import matplotlib.pyplot as plt
    # fns.remove('a010.fit')
    # fns.remove('a015.fit')
    input_path = Path(input_dir)
    output_path = Path(output_dir)
    print(filelist)
    fwhm_list = []
    focus_list = []
    for index, fn in enumerate(filelist):
        im_path = input_path / fn
        # print(im_path)
        img = fitsio.read(im_path)
        header = fitsio.read_header(im_path)
        # focus = float(header['INSTFOCU'])
        focus = focuses[index]
        if abs(focus - float(header["INSTFOCU"])) > 0.1 \
            or abs(focus - float(header["CMDFOCUS"])) > 0.1:
            logging.warning("focus values are not consistent! file: %s. Focus given: %s, from header: inst %s, cmd %s",
                            fn, focus, header["INSTFOCU"], header["CMDFOCUS"])
        if isinstance(center_x, list):
            y, x = center_y[index], center_x[index]
        else:
            y, x = center_y, center_x
        img1 = img[x-half_sidelen:x+half_sidelen, y-half_sidelen:y+half_sidelen]

        median_sky = np.median(np.concatenate([img1[:, :10].flatten(), img1[:, -20:].flatten(), img1[:10].flatten(), img1[-20:].flatten()]))
        img1 = img1 - median_sky
        # print(np.max(img1))

        median_sky = np.median(np.concatenate([img1[:, :10].flatten(), img1[:, -20:].flatten(), img1[:10].flatten(), img1[-20:].flatten()]))
        img1 = img1 - median_sky

        

        nea = np.sum(img1)**2/np.sum(img1**2)
        fwhm = np.sqrt(nea / (4 * np.pi)) * 2.3548
        print(f"{fn}, focus: {focus}, INST: {header['INSTFOCU']}, CMD: {header['CMDFOCUS']}, fwhm: {fwhm}")
        plt.figure(figsize=(5, 5))
        plt.imshow(img1, cmap='gray', vmin=-50, vmax=1000)
        plt.title(f'{fn}, filter: {filter_name}, focus: {focus}, INST: {header["INSTFOCU"]}, fwhm: {fwhm:.2f}')
        # plt.show()
        plt.savefig(output_path / "focus_{}.png".format(fn.rsplit('.')[0]))
        fwhm_list.append(fwhm)
        focus_list.append(focus)
    focus_list, fwhm_list = np.array(focus_list), np.array(fwhm_list)
    plt.figure(figsize=(8, 5))
    plt.plot(focus_list, fwhm_list, '.')
    plt.xlabel('Focus adjustment (mm)')
    plt.ylabel('FWHM (in pixels)')
    plt.savefig(output_path / f"focus_fwhm_{filter_name}.png")
    # mask = focus_list>-3
    # mask &= focus_list<-2
    x = focus_list
    y = fwhm_list
    res = rlm_fit1d(x, y, t=1, order=2)
    x_plot = np.linspace(x.min()-0.1, x.max()+0.1, 10000)
    y_plot = poly_val1d(x_plot, res)
    best_focus = x_plot[np.argmin(y_plot)]
    print('Best focus: {:.2f}'.format(best_focus))
    plt.plot(x, y, '.')
    plt.plot(x_plot, y_plot)
    plt.axvline(best_focus)
    # plt.xlim(0, 60)
    plt.xlabel('Focus adjustment (mm)')
    plt.ylabel('FWHM (in pixels)')
    plt.title(f'{filter_name} filter best focus: {best_focus:.2f}')
    plt.savefig(output_path / f"best_focus_{filter_name}.png")
    # add uncertainty here
    print("Best focus: {:.2f}".format(best_focus))


if __file__ == "__main__":
    parser = argparse.ArgumentParser("Calculate focus given a list of images")
    parser.add_argument("input_dir", '--in', type=str, help="Input directory")
    parser.add_argument("output_dir", "--out", type=str, help="Output directory")
    parser.add_argument("images", "--im", nargs="+", help="List of images")
    parser.add_argument("lower_left_xy", "--ll", nargs=2, type=int, 
                        help="Lower left corner of the image region to extract focus from")
    parser.add_argument("upper_right_xy", "--ur", nargs=2, type=int,
                        help="Upper right corner of the image region to extract focus from")
    
    
    